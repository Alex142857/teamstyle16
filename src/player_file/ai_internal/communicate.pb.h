// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: communicate.proto

#ifndef PROTOBUF_communicate_2eproto__INCLUDED
#define PROTOBUF_communicate_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace teamstyle16 {
namespace communicate {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_communicate_2eproto();
void protobuf_AssignDesc_communicate_2eproto();
void protobuf_ShutdownFile_communicate_2eproto();

class Position;
class Element;
class Element_Size;
class Map;
class StableInfo;
class RoundInfo;
class RoundInfo_ProductionEntry;

// ===================================================================

class Position : public ::google::protobuf::Message {
 public:
  Position();
  virtual ~Position();

  Position(const Position& from);

  inline Position& operator=(const Position& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Position& default_instance();

  void Swap(Position* other);

  // implements Message ----------------------------------------------

  Position* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Position& from);
  void MergeFrom(const Position& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // required int32 y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // required int32 z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline ::google::protobuf::int32 z() const;
  inline void set_z(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:teamstyle16.communicate.Position)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 z_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_communicate_2eproto();
  friend void protobuf_AssignDesc_communicate_2eproto();
  friend void protobuf_ShutdownFile_communicate_2eproto();

  void InitAsDefaultInstance();
  static Position* default_instance_;
};
// -------------------------------------------------------------------

class Element_Size : public ::google::protobuf::Message {
 public:
  Element_Size();
  virtual ~Element_Size();

  Element_Size(const Element_Size& from);

  inline Element_Size& operator=(const Element_Size& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Element_Size& default_instance();

  void Swap(Element_Size* other);

  // implements Message ----------------------------------------------

  Element_Size* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Element_Size& from);
  void MergeFrom(const Element_Size& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // required int32 y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:teamstyle16.communicate.Element.Size)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_communicate_2eproto();
  friend void protobuf_AssignDesc_communicate_2eproto();
  friend void protobuf_ShutdownFile_communicate_2eproto();

  void InitAsDefaultInstance();
  static Element_Size* default_instance_;
};
// -------------------------------------------------------------------

class Element : public ::google::protobuf::Message {
 public:
  Element();
  virtual ~Element();

  Element(const Element& from);

  inline Element& operator=(const Element& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Element& default_instance();

  void Swap(Element* other);

  // implements Message ----------------------------------------------

  Element* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Element& from);
  void MergeFrom(const Element& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Element_Size Size;

  // accessors -------------------------------------------------------

  // required int32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // required int32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // required .teamstyle16.communicate.Position pos = 3;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 3;
  inline const ::teamstyle16::communicate::Position& pos() const;
  inline ::teamstyle16::communicate::Position* mutable_pos();
  inline ::teamstyle16::communicate::Position* release_pos();
  inline void set_allocated_pos(::teamstyle16::communicate::Position* pos);

  // optional .teamstyle16.communicate.Element.Size size = 4;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 4;
  inline const ::teamstyle16::communicate::Element_Size& size() const;
  inline ::teamstyle16::communicate::Element_Size* mutable_size();
  inline ::teamstyle16::communicate::Element_Size* release_size();
  inline void set_allocated_size(::teamstyle16::communicate::Element_Size* size);

  // required bool visible = 5;
  inline bool has_visible() const;
  inline void clear_visible();
  static const int kVisibleFieldNumber = 5;
  inline bool visible() const;
  inline void set_visible(bool value);

  // optional int32 team = 6 [default = 2];
  inline bool has_team() const;
  inline void clear_team();
  static const int kTeamFieldNumber = 6;
  inline ::google::protobuf::int32 team() const;
  inline void set_team(::google::protobuf::int32 value);

  // optional int32 health = 7;
  inline bool has_health() const;
  inline void clear_health();
  static const int kHealthFieldNumber = 7;
  inline ::google::protobuf::int32 health() const;
  inline void set_health(::google::protobuf::int32 value);

  // optional int32 fuel = 8;
  inline bool has_fuel() const;
  inline void clear_fuel();
  static const int kFuelFieldNumber = 8;
  inline ::google::protobuf::int32 fuel() const;
  inline void set_fuel(::google::protobuf::int32 value);

  // optional int32 ammo = 9;
  inline bool has_ammo() const;
  inline void clear_ammo();
  static const int kAmmoFieldNumber = 9;
  inline ::google::protobuf::int32 ammo() const;
  inline void set_ammo(::google::protobuf::int32 value);

  // optional int32 metal = 10;
  inline bool has_metal() const;
  inline void clear_metal();
  static const int kMetalFieldNumber = 10;
  inline ::google::protobuf::int32 metal() const;
  inline void set_metal(::google::protobuf::int32 value);

  // optional .teamstyle16.communicate.Position dest = 11;
  inline bool has_dest() const;
  inline void clear_dest();
  static const int kDestFieldNumber = 11;
  inline const ::teamstyle16::communicate::Position& dest() const;
  inline ::teamstyle16::communicate::Position* mutable_dest();
  inline ::teamstyle16::communicate::Position* release_dest();
  inline void set_allocated_dest(::teamstyle16::communicate::Position* dest);

  // @@protoc_insertion_point(class_scope:teamstyle16.communicate.Element)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_visible();
  inline void clear_has_visible();
  inline void set_has_team();
  inline void clear_has_team();
  inline void set_has_health();
  inline void clear_has_health();
  inline void set_has_fuel();
  inline void clear_has_fuel();
  inline void set_has_ammo();
  inline void clear_has_ammo();
  inline void set_has_metal();
  inline void clear_has_metal();
  inline void set_has_dest();
  inline void clear_has_dest();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 index_;
  ::google::protobuf::int32 type_;
  ::teamstyle16::communicate::Position* pos_;
  ::teamstyle16::communicate::Element_Size* size_;
  bool visible_;
  ::google::protobuf::int32 team_;
  ::google::protobuf::int32 health_;
  ::google::protobuf::int32 fuel_;
  ::google::protobuf::int32 ammo_;
  ::google::protobuf::int32 metal_;
  ::teamstyle16::communicate::Position* dest_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_communicate_2eproto();
  friend void protobuf_AssignDesc_communicate_2eproto();
  friend void protobuf_ShutdownFile_communicate_2eproto();

  void InitAsDefaultInstance();
  static Element* default_instance_;
};
// -------------------------------------------------------------------

class Map : public ::google::protobuf::Message {
 public:
  Map();
  virtual ~Map();

  Map(const Map& from);

  inline Map& operator=(const Map& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Map& default_instance();

  void Swap(Map* other);

  // implements Message ----------------------------------------------

  Map* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Map& from);
  void MergeFrom(const Map& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 x_max = 1;
  inline bool has_x_max() const;
  inline void clear_x_max();
  static const int kXMaxFieldNumber = 1;
  inline ::google::protobuf::int32 x_max() const;
  inline void set_x_max(::google::protobuf::int32 value);

  // required int32 y_max = 2;
  inline bool has_y_max() const;
  inline void clear_y_max();
  static const int kYMaxFieldNumber = 2;
  inline ::google::protobuf::int32 y_max() const;
  inline void set_y_max(::google::protobuf::int32 value);

  // repeated int32 terrain = 3;
  inline int terrain_size() const;
  inline void clear_terrain();
  static const int kTerrainFieldNumber = 3;
  inline ::google::protobuf::int32 terrain(int index) const;
  inline void set_terrain(int index, ::google::protobuf::int32 value);
  inline void add_terrain(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      terrain() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_terrain();

  // @@protoc_insertion_point(class_scope:teamstyle16.communicate.Map)
 private:
  inline void set_has_x_max();
  inline void clear_has_x_max();
  inline void set_has_y_max();
  inline void clear_has_y_max();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 x_max_;
  ::google::protobuf::int32 y_max_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > terrain_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_communicate_2eproto();
  friend void protobuf_AssignDesc_communicate_2eproto();
  friend void protobuf_ShutdownFile_communicate_2eproto();

  void InitAsDefaultInstance();
  static Map* default_instance_;
};
// -------------------------------------------------------------------

class StableInfo : public ::google::protobuf::Message {
 public:
  StableInfo();
  virtual ~StableInfo();

  StableInfo(const StableInfo& from);

  inline StableInfo& operator=(const StableInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StableInfo& default_instance();

  void Swap(StableInfo* other);

  // implements Message ----------------------------------------------

  StableInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StableInfo& from);
  void MergeFrom(const StableInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .teamstyle16.communicate.Map map = 1;
  inline bool has_map() const;
  inline void clear_map();
  static const int kMapFieldNumber = 1;
  inline const ::teamstyle16::communicate::Map& map() const;
  inline ::teamstyle16::communicate::Map* mutable_map();
  inline ::teamstyle16::communicate::Map* release_map();
  inline void set_allocated_map(::teamstyle16::communicate::Map* map);

  // required int32 team_num = 2;
  inline bool has_team_num() const;
  inline void clear_team_num();
  static const int kTeamNumFieldNumber = 2;
  inline ::google::protobuf::int32 team_num() const;
  inline void set_team_num(::google::protobuf::int32 value);

  // optional int32 weather = 3;
  inline bool has_weather() const;
  inline void clear_weather();
  static const int kWeatherFieldNumber = 3;
  inline ::google::protobuf::int32 weather() const;
  inline void set_weather(::google::protobuf::int32 value);

  // optional int32 population_limit = 4;
  inline bool has_population_limit() const;
  inline void clear_population_limit();
  static const int kPopulationLimitFieldNumber = 4;
  inline ::google::protobuf::int32 population_limit() const;
  inline void set_population_limit(::google::protobuf::int32 value);

  // optional int32 round_limit = 5;
  inline bool has_round_limit() const;
  inline void clear_round_limit();
  static const int kRoundLimitFieldNumber = 5;
  inline ::google::protobuf::int32 round_limit() const;
  inline void set_round_limit(::google::protobuf::int32 value);

  // optional float time_per_round = 6;
  inline bool has_time_per_round() const;
  inline void clear_time_per_round();
  static const int kTimePerRoundFieldNumber = 6;
  inline float time_per_round() const;
  inline void set_time_per_round(float value);

  // @@protoc_insertion_point(class_scope:teamstyle16.communicate.StableInfo)
 private:
  inline void set_has_map();
  inline void clear_has_map();
  inline void set_has_team_num();
  inline void clear_has_team_num();
  inline void set_has_weather();
  inline void clear_has_weather();
  inline void set_has_population_limit();
  inline void clear_has_population_limit();
  inline void set_has_round_limit();
  inline void clear_has_round_limit();
  inline void set_has_time_per_round();
  inline void clear_has_time_per_round();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::teamstyle16::communicate::Map* map_;
  ::google::protobuf::int32 team_num_;
  ::google::protobuf::int32 weather_;
  ::google::protobuf::int32 population_limit_;
  ::google::protobuf::int32 round_limit_;
  float time_per_round_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_communicate_2eproto();
  friend void protobuf_AssignDesc_communicate_2eproto();
  friend void protobuf_ShutdownFile_communicate_2eproto();

  void InitAsDefaultInstance();
  static StableInfo* default_instance_;
};
// -------------------------------------------------------------------

class RoundInfo_ProductionEntry : public ::google::protobuf::Message {
 public:
  RoundInfo_ProductionEntry();
  virtual ~RoundInfo_ProductionEntry();

  RoundInfo_ProductionEntry(const RoundInfo_ProductionEntry& from);

  inline RoundInfo_ProductionEntry& operator=(const RoundInfo_ProductionEntry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoundInfo_ProductionEntry& default_instance();

  void Swap(RoundInfo_ProductionEntry* other);

  // implements Message ----------------------------------------------

  RoundInfo_ProductionEntry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoundInfo_ProductionEntry& from);
  void MergeFrom(const RoundInfo_ProductionEntry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // required int32 round_left = 2;
  inline bool has_round_left() const;
  inline void clear_round_left();
  static const int kRoundLeftFieldNumber = 2;
  inline ::google::protobuf::int32 round_left() const;
  inline void set_round_left(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:teamstyle16.communicate.RoundInfo.ProductionEntry)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_round_left();
  inline void clear_has_round_left();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 round_left_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_communicate_2eproto();
  friend void protobuf_AssignDesc_communicate_2eproto();
  friend void protobuf_ShutdownFile_communicate_2eproto();

  void InitAsDefaultInstance();
  static RoundInfo_ProductionEntry* default_instance_;
};
// -------------------------------------------------------------------

class RoundInfo : public ::google::protobuf::Message {
 public:
  RoundInfo();
  virtual ~RoundInfo();

  RoundInfo(const RoundInfo& from);

  inline RoundInfo& operator=(const RoundInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoundInfo& default_instance();

  void Swap(RoundInfo* other);

  // implements Message ----------------------------------------------

  RoundInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoundInfo& from);
  void MergeFrom(const RoundInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RoundInfo_ProductionEntry ProductionEntry;

  // accessors -------------------------------------------------------

  // required int32 round = 1;
  inline bool has_round() const;
  inline void clear_round();
  static const int kRoundFieldNumber = 1;
  inline ::google::protobuf::int32 round() const;
  inline void set_round(::google::protobuf::int32 value);

  // repeated int32 score = 2;
  inline int score_size() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 2;
  inline ::google::protobuf::int32 score(int index) const;
  inline void set_score(int index, ::google::protobuf::int32 value);
  inline void add_score(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      score() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_score();

  // optional int32 population = 3;
  inline bool has_population() const;
  inline void clear_population();
  static const int kPopulationFieldNumber = 3;
  inline ::google::protobuf::int32 population() const;
  inline void set_population(::google::protobuf::int32 value);

  // repeated .teamstyle16.communicate.Element element = 4;
  inline int element_size() const;
  inline void clear_element();
  static const int kElementFieldNumber = 4;
  inline const ::teamstyle16::communicate::Element& element(int index) const;
  inline ::teamstyle16::communicate::Element* mutable_element(int index);
  inline ::teamstyle16::communicate::Element* add_element();
  inline const ::google::protobuf::RepeatedPtrField< ::teamstyle16::communicate::Element >&
      element() const;
  inline ::google::protobuf::RepeatedPtrField< ::teamstyle16::communicate::Element >*
      mutable_element();

  // repeated .teamstyle16.communicate.RoundInfo.ProductionEntry production_list = 5;
  inline int production_list_size() const;
  inline void clear_production_list();
  static const int kProductionListFieldNumber = 5;
  inline const ::teamstyle16::communicate::RoundInfo_ProductionEntry& production_list(int index) const;
  inline ::teamstyle16::communicate::RoundInfo_ProductionEntry* mutable_production_list(int index);
  inline ::teamstyle16::communicate::RoundInfo_ProductionEntry* add_production_list();
  inline const ::google::protobuf::RepeatedPtrField< ::teamstyle16::communicate::RoundInfo_ProductionEntry >&
      production_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::teamstyle16::communicate::RoundInfo_ProductionEntry >*
      mutable_production_list();

  // @@protoc_insertion_point(class_scope:teamstyle16.communicate.RoundInfo)
 private:
  inline void set_has_round();
  inline void clear_has_round();
  inline void set_has_population();
  inline void clear_has_population();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > score_;
  ::google::protobuf::int32 round_;
  ::google::protobuf::int32 population_;
  ::google::protobuf::RepeatedPtrField< ::teamstyle16::communicate::Element > element_;
  ::google::protobuf::RepeatedPtrField< ::teamstyle16::communicate::RoundInfo_ProductionEntry > production_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_communicate_2eproto();
  friend void protobuf_AssignDesc_communicate_2eproto();
  friend void protobuf_ShutdownFile_communicate_2eproto();

  void InitAsDefaultInstance();
  static RoundInfo* default_instance_;
};
// ===================================================================


// ===================================================================

// Position

// required int32 x = 1;
inline bool Position::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Position::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Position::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Position::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 Position::x() const {
  return x_;
}
inline void Position::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
}

// required int32 y = 2;
inline bool Position::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Position::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Position::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Position::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 Position::y() const {
  return y_;
}
inline void Position::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
}

// required int32 z = 3;
inline bool Position::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Position::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Position::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Position::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline ::google::protobuf::int32 Position::z() const {
  return z_;
}
inline void Position::set_z(::google::protobuf::int32 value) {
  set_has_z();
  z_ = value;
}

// -------------------------------------------------------------------

// Element_Size

// required int32 x = 1;
inline bool Element_Size::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Element_Size::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Element_Size::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Element_Size::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 Element_Size::x() const {
  return x_;
}
inline void Element_Size::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
}

// required int32 y = 2;
inline bool Element_Size::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Element_Size::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Element_Size::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Element_Size::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 Element_Size::y() const {
  return y_;
}
inline void Element_Size::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
}

// -------------------------------------------------------------------

// Element

// required int32 index = 1;
inline bool Element::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Element::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Element::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Element::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 Element::index() const {
  return index_;
}
inline void Element::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
}

// required int32 type = 2;
inline bool Element::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Element::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Element::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Element::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 Element::type() const {
  return type_;
}
inline void Element::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required .teamstyle16.communicate.Position pos = 3;
inline bool Element::has_pos() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Element::set_has_pos() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Element::clear_has_pos() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Element::clear_pos() {
  if (pos_ != NULL) pos_->::teamstyle16::communicate::Position::Clear();
  clear_has_pos();
}
inline const ::teamstyle16::communicate::Position& Element::pos() const {
  return pos_ != NULL ? *pos_ : *default_instance_->pos_;
}
inline ::teamstyle16::communicate::Position* Element::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) pos_ = new ::teamstyle16::communicate::Position;
  return pos_;
}
inline ::teamstyle16::communicate::Position* Element::release_pos() {
  clear_has_pos();
  ::teamstyle16::communicate::Position* temp = pos_;
  pos_ = NULL;
  return temp;
}
inline void Element::set_allocated_pos(::teamstyle16::communicate::Position* pos) {
  delete pos_;
  pos_ = pos;
  if (pos) {
    set_has_pos();
  } else {
    clear_has_pos();
  }
}

// optional .teamstyle16.communicate.Element.Size size = 4;
inline bool Element::has_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Element::set_has_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Element::clear_has_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Element::clear_size() {
  if (size_ != NULL) size_->::teamstyle16::communicate::Element_Size::Clear();
  clear_has_size();
}
inline const ::teamstyle16::communicate::Element_Size& Element::size() const {
  return size_ != NULL ? *size_ : *default_instance_->size_;
}
inline ::teamstyle16::communicate::Element_Size* Element::mutable_size() {
  set_has_size();
  if (size_ == NULL) size_ = new ::teamstyle16::communicate::Element_Size;
  return size_;
}
inline ::teamstyle16::communicate::Element_Size* Element::release_size() {
  clear_has_size();
  ::teamstyle16::communicate::Element_Size* temp = size_;
  size_ = NULL;
  return temp;
}
inline void Element::set_allocated_size(::teamstyle16::communicate::Element_Size* size) {
  delete size_;
  size_ = size;
  if (size) {
    set_has_size();
  } else {
    clear_has_size();
  }
}

// required bool visible = 5;
inline bool Element::has_visible() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Element::set_has_visible() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Element::clear_has_visible() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Element::clear_visible() {
  visible_ = false;
  clear_has_visible();
}
inline bool Element::visible() const {
  return visible_;
}
inline void Element::set_visible(bool value) {
  set_has_visible();
  visible_ = value;
}

// optional int32 team = 6 [default = 2];
inline bool Element::has_team() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Element::set_has_team() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Element::clear_has_team() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Element::clear_team() {
  team_ = 2;
  clear_has_team();
}
inline ::google::protobuf::int32 Element::team() const {
  return team_;
}
inline void Element::set_team(::google::protobuf::int32 value) {
  set_has_team();
  team_ = value;
}

// optional int32 health = 7;
inline bool Element::has_health() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Element::set_has_health() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Element::clear_has_health() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Element::clear_health() {
  health_ = 0;
  clear_has_health();
}
inline ::google::protobuf::int32 Element::health() const {
  return health_;
}
inline void Element::set_health(::google::protobuf::int32 value) {
  set_has_health();
  health_ = value;
}

// optional int32 fuel = 8;
inline bool Element::has_fuel() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Element::set_has_fuel() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Element::clear_has_fuel() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Element::clear_fuel() {
  fuel_ = 0;
  clear_has_fuel();
}
inline ::google::protobuf::int32 Element::fuel() const {
  return fuel_;
}
inline void Element::set_fuel(::google::protobuf::int32 value) {
  set_has_fuel();
  fuel_ = value;
}

// optional int32 ammo = 9;
inline bool Element::has_ammo() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Element::set_has_ammo() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Element::clear_has_ammo() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Element::clear_ammo() {
  ammo_ = 0;
  clear_has_ammo();
}
inline ::google::protobuf::int32 Element::ammo() const {
  return ammo_;
}
inline void Element::set_ammo(::google::protobuf::int32 value) {
  set_has_ammo();
  ammo_ = value;
}

// optional int32 metal = 10;
inline bool Element::has_metal() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Element::set_has_metal() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Element::clear_has_metal() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Element::clear_metal() {
  metal_ = 0;
  clear_has_metal();
}
inline ::google::protobuf::int32 Element::metal() const {
  return metal_;
}
inline void Element::set_metal(::google::protobuf::int32 value) {
  set_has_metal();
  metal_ = value;
}

// optional .teamstyle16.communicate.Position dest = 11;
inline bool Element::has_dest() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Element::set_has_dest() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Element::clear_has_dest() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Element::clear_dest() {
  if (dest_ != NULL) dest_->::teamstyle16::communicate::Position::Clear();
  clear_has_dest();
}
inline const ::teamstyle16::communicate::Position& Element::dest() const {
  return dest_ != NULL ? *dest_ : *default_instance_->dest_;
}
inline ::teamstyle16::communicate::Position* Element::mutable_dest() {
  set_has_dest();
  if (dest_ == NULL) dest_ = new ::teamstyle16::communicate::Position;
  return dest_;
}
inline ::teamstyle16::communicate::Position* Element::release_dest() {
  clear_has_dest();
  ::teamstyle16::communicate::Position* temp = dest_;
  dest_ = NULL;
  return temp;
}
inline void Element::set_allocated_dest(::teamstyle16::communicate::Position* dest) {
  delete dest_;
  dest_ = dest;
  if (dest) {
    set_has_dest();
  } else {
    clear_has_dest();
  }
}

// -------------------------------------------------------------------

// Map

// required int32 x_max = 1;
inline bool Map::has_x_max() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Map::set_has_x_max() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Map::clear_has_x_max() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Map::clear_x_max() {
  x_max_ = 0;
  clear_has_x_max();
}
inline ::google::protobuf::int32 Map::x_max() const {
  return x_max_;
}
inline void Map::set_x_max(::google::protobuf::int32 value) {
  set_has_x_max();
  x_max_ = value;
}

// required int32 y_max = 2;
inline bool Map::has_y_max() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Map::set_has_y_max() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Map::clear_has_y_max() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Map::clear_y_max() {
  y_max_ = 0;
  clear_has_y_max();
}
inline ::google::protobuf::int32 Map::y_max() const {
  return y_max_;
}
inline void Map::set_y_max(::google::protobuf::int32 value) {
  set_has_y_max();
  y_max_ = value;
}

// repeated int32 terrain = 3;
inline int Map::terrain_size() const {
  return terrain_.size();
}
inline void Map::clear_terrain() {
  terrain_.Clear();
}
inline ::google::protobuf::int32 Map::terrain(int index) const {
  return terrain_.Get(index);
}
inline void Map::set_terrain(int index, ::google::protobuf::int32 value) {
  terrain_.Set(index, value);
}
inline void Map::add_terrain(::google::protobuf::int32 value) {
  terrain_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Map::terrain() const {
  return terrain_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Map::mutable_terrain() {
  return &terrain_;
}

// -------------------------------------------------------------------

// StableInfo

// required .teamstyle16.communicate.Map map = 1;
inline bool StableInfo::has_map() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StableInfo::set_has_map() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StableInfo::clear_has_map() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StableInfo::clear_map() {
  if (map_ != NULL) map_->::teamstyle16::communicate::Map::Clear();
  clear_has_map();
}
inline const ::teamstyle16::communicate::Map& StableInfo::map() const {
  return map_ != NULL ? *map_ : *default_instance_->map_;
}
inline ::teamstyle16::communicate::Map* StableInfo::mutable_map() {
  set_has_map();
  if (map_ == NULL) map_ = new ::teamstyle16::communicate::Map;
  return map_;
}
inline ::teamstyle16::communicate::Map* StableInfo::release_map() {
  clear_has_map();
  ::teamstyle16::communicate::Map* temp = map_;
  map_ = NULL;
  return temp;
}
inline void StableInfo::set_allocated_map(::teamstyle16::communicate::Map* map) {
  delete map_;
  map_ = map;
  if (map) {
    set_has_map();
  } else {
    clear_has_map();
  }
}

// required int32 team_num = 2;
inline bool StableInfo::has_team_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StableInfo::set_has_team_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StableInfo::clear_has_team_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StableInfo::clear_team_num() {
  team_num_ = 0;
  clear_has_team_num();
}
inline ::google::protobuf::int32 StableInfo::team_num() const {
  return team_num_;
}
inline void StableInfo::set_team_num(::google::protobuf::int32 value) {
  set_has_team_num();
  team_num_ = value;
}

// optional int32 weather = 3;
inline bool StableInfo::has_weather() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StableInfo::set_has_weather() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StableInfo::clear_has_weather() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StableInfo::clear_weather() {
  weather_ = 0;
  clear_has_weather();
}
inline ::google::protobuf::int32 StableInfo::weather() const {
  return weather_;
}
inline void StableInfo::set_weather(::google::protobuf::int32 value) {
  set_has_weather();
  weather_ = value;
}

// optional int32 population_limit = 4;
inline bool StableInfo::has_population_limit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StableInfo::set_has_population_limit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StableInfo::clear_has_population_limit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StableInfo::clear_population_limit() {
  population_limit_ = 0;
  clear_has_population_limit();
}
inline ::google::protobuf::int32 StableInfo::population_limit() const {
  return population_limit_;
}
inline void StableInfo::set_population_limit(::google::protobuf::int32 value) {
  set_has_population_limit();
  population_limit_ = value;
}

// optional int32 round_limit = 5;
inline bool StableInfo::has_round_limit() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void StableInfo::set_has_round_limit() {
  _has_bits_[0] |= 0x00000010u;
}
inline void StableInfo::clear_has_round_limit() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void StableInfo::clear_round_limit() {
  round_limit_ = 0;
  clear_has_round_limit();
}
inline ::google::protobuf::int32 StableInfo::round_limit() const {
  return round_limit_;
}
inline void StableInfo::set_round_limit(::google::protobuf::int32 value) {
  set_has_round_limit();
  round_limit_ = value;
}

// optional float time_per_round = 6;
inline bool StableInfo::has_time_per_round() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void StableInfo::set_has_time_per_round() {
  _has_bits_[0] |= 0x00000020u;
}
inline void StableInfo::clear_has_time_per_round() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void StableInfo::clear_time_per_round() {
  time_per_round_ = 0;
  clear_has_time_per_round();
}
inline float StableInfo::time_per_round() const {
  return time_per_round_;
}
inline void StableInfo::set_time_per_round(float value) {
  set_has_time_per_round();
  time_per_round_ = value;
}

// -------------------------------------------------------------------

// RoundInfo_ProductionEntry

// required int32 type = 1;
inline bool RoundInfo_ProductionEntry::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoundInfo_ProductionEntry::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoundInfo_ProductionEntry::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoundInfo_ProductionEntry::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 RoundInfo_ProductionEntry::type() const {
  return type_;
}
inline void RoundInfo_ProductionEntry::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required int32 round_left = 2;
inline bool RoundInfo_ProductionEntry::has_round_left() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoundInfo_ProductionEntry::set_has_round_left() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoundInfo_ProductionEntry::clear_has_round_left() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoundInfo_ProductionEntry::clear_round_left() {
  round_left_ = 0;
  clear_has_round_left();
}
inline ::google::protobuf::int32 RoundInfo_ProductionEntry::round_left() const {
  return round_left_;
}
inline void RoundInfo_ProductionEntry::set_round_left(::google::protobuf::int32 value) {
  set_has_round_left();
  round_left_ = value;
}

// -------------------------------------------------------------------

// RoundInfo

// required int32 round = 1;
inline bool RoundInfo::has_round() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoundInfo::set_has_round() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoundInfo::clear_has_round() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoundInfo::clear_round() {
  round_ = 0;
  clear_has_round();
}
inline ::google::protobuf::int32 RoundInfo::round() const {
  return round_;
}
inline void RoundInfo::set_round(::google::protobuf::int32 value) {
  set_has_round();
  round_ = value;
}

// repeated int32 score = 2;
inline int RoundInfo::score_size() const {
  return score_.size();
}
inline void RoundInfo::clear_score() {
  score_.Clear();
}
inline ::google::protobuf::int32 RoundInfo::score(int index) const {
  return score_.Get(index);
}
inline void RoundInfo::set_score(int index, ::google::protobuf::int32 value) {
  score_.Set(index, value);
}
inline void RoundInfo::add_score(::google::protobuf::int32 value) {
  score_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
RoundInfo::score() const {
  return score_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
RoundInfo::mutable_score() {
  return &score_;
}

// optional int32 population = 3;
inline bool RoundInfo::has_population() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoundInfo::set_has_population() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RoundInfo::clear_has_population() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RoundInfo::clear_population() {
  population_ = 0;
  clear_has_population();
}
inline ::google::protobuf::int32 RoundInfo::population() const {
  return population_;
}
inline void RoundInfo::set_population(::google::protobuf::int32 value) {
  set_has_population();
  population_ = value;
}

// repeated .teamstyle16.communicate.Element element = 4;
inline int RoundInfo::element_size() const {
  return element_.size();
}
inline void RoundInfo::clear_element() {
  element_.Clear();
}
inline const ::teamstyle16::communicate::Element& RoundInfo::element(int index) const {
  return element_.Get(index);
}
inline ::teamstyle16::communicate::Element* RoundInfo::mutable_element(int index) {
  return element_.Mutable(index);
}
inline ::teamstyle16::communicate::Element* RoundInfo::add_element() {
  return element_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::teamstyle16::communicate::Element >&
RoundInfo::element() const {
  return element_;
}
inline ::google::protobuf::RepeatedPtrField< ::teamstyle16::communicate::Element >*
RoundInfo::mutable_element() {
  return &element_;
}

// repeated .teamstyle16.communicate.RoundInfo.ProductionEntry production_list = 5;
inline int RoundInfo::production_list_size() const {
  return production_list_.size();
}
inline void RoundInfo::clear_production_list() {
  production_list_.Clear();
}
inline const ::teamstyle16::communicate::RoundInfo_ProductionEntry& RoundInfo::production_list(int index) const {
  return production_list_.Get(index);
}
inline ::teamstyle16::communicate::RoundInfo_ProductionEntry* RoundInfo::mutable_production_list(int index) {
  return production_list_.Mutable(index);
}
inline ::teamstyle16::communicate::RoundInfo_ProductionEntry* RoundInfo::add_production_list() {
  return production_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::teamstyle16::communicate::RoundInfo_ProductionEntry >&
RoundInfo::production_list() const {
  return production_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::teamstyle16::communicate::RoundInfo_ProductionEntry >*
RoundInfo::mutable_production_list() {
  return &production_list_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace communicate
}  // namespace teamstyle16

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_communicate_2eproto__INCLUDED
